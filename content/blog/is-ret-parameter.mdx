---
title: "Почему одного is_ret=true недостаточно"
description: "На iOS невозможно чисто заминусовать аудиторию. Поэтому важно правильно учитывать повторные действия пользователей и отличать их от новых."
date: "2025-09-07"
tags: ["iOS", "Атрибуция", "Трекинг", "MMP"]
status: "published"
---

В прошлом посте я рассказал, что на iOS невозможно «чисто» заминусовать аудиторию — даже если вы всё исключаете, реклама всё равно будет показываться ранее установившим.

Поэтому важно правильно учитывать **повторные действия пользователей** и отличать их от новых. Для этого используется параметр `is_ret=true`.

## Что такое is_ret=true

В мобильных трекерах (например, AppsFlyer) этот параметр добавляется в трекинговые ссылки, чтобы обозначить:
- это не кампания по привлечению
- это кампания по возврату пользователей

Чаще всего в UA-источниках (Mintegral, Unity, Hybe, AppLovin, Bigo, Яндекс) его не используют, если только это не классический RET с таргетингом на определённую аудиторию.

**НО!**

## Живой пример

Источник A привёл пользователя на установку. Через 3 дня тот же пользователь видит рекламу от источника B (тоже UA), кликает, открывает приложение и делает покупку.

Если `is_ret=true` не проставлен, покупка уходит источнику A — тому, кто привёл install.

Это логично:
- прошло всего 3 дня
- пользователь, скорее всего, и так бы вернулся
- источник A продолжал влиять на его поведение

(тут пишу в большей степени про e-commerce)

### Теперь другой кейс

Пользователь установил приложение с источника A, потом 30 дней подряд не заходил в приложение. Затем увидел рекламу от источника B, снова открыл приложение и сделал покупку.

Если параметр `is_ret=true` не проставлен — покупка снова уходит источнику A. Хотя в этом случае именно источник B вернул пользователя и спровоцировал покупку. Это и есть потеря инкрементального эффекта.

## Почему одного параметра недостаточно

Чтобы фиксировать возвраты корректно, нужно не только использовать `is_ret=true`, но и задать границы:

- `inactivity window` — определяет, сколько дней подряд пользователь должен не заходить в приложение, чтобы его заход с рекламы мы считали реэнгейджментом
- `re-engagement window` — окно между (показом или кликом) до реэнгейджмента

## Примеры

Пользователь не заходил 14 дней подряд, вернулся после рекламы — данный реэнгейджмент инкрементальный.

(тут я пишу инкрементален, но у вас на голове своя голова — вы должны сами определить, какие окна инкрементальны для вашего бизнеса)

## Рекомендованные параметры

- `inactivity window`: 7–14 дней
- `re-engagement window`: 3–7 дней

Значения подбираются под поведение вашей аудитории и продуктовый цикл. Окна просто прописал, какие можно взять, но определяете вы их с помощью своей аналитики.

## Вывод

`is_ret=true` — это просто флаг.

Без окон вы переоцениваете вклад своего источника, где крутите параметр `is_ret=true`, и ошибочно приписываете результат не тем источникам.

## Продолжение

В следующем посте расскажу про параметр **AppsFlyer ID** и какую важную роль он играет в атрибуции, и как связан с параметром `is_ret=true`.

*При использовании параметра учитывайте дедупликацию событий.*

*Данный пост носит только ознакомительный характер, я не продвигаю идею, что вам обязательно или не обязательно его использовать.*
